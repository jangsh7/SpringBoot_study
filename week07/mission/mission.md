## RestControllerAdvice 장점

### 1) 예외 응답 형식 통일
- 서비스 전역에서 발생하는 다양한 예외를 **동일한 JSON 스키마**로 반환합니다.
- 클라이언트(웹/앱)에서는 에러 파싱 로직을 한 번만 작성하면 됩니다.
- 예:
  ```json
  { "success": false, "code": "E400", "message": "잘못된 요청입니다.", "data": "필드 오류 상세" }
  ```
### 2) 중복 제거 & 관심사 분리
- 컨트롤러마다 `try-catch`를 반복하지 않아도 됩니다.
- 비즈니스 로직(서비스/컨트롤러)과 인프라 로직(에러 포맷, 로깅)이 분리되어 코드가 간결해집니다.

### 3) 로깅/모니터링 표준화
- 공통 핸들러에서 로그 수준, 포맷, 트레이스 ID 등을 일관되게 기록할 수 있습니다.
- 장애 분석 시 검색 가능성(Observability) 이 좋아집니다.

### 4) 검증 오류 일괄 처리
- `@Valid`/`BindingResult`, `MethodArgumentNotValidException`, `BindException` 등을 한 곳에서 가공하여 필드별 메시지로 내려줄 수 있습니다.
- 클라이언트에 친화적인 오류 구조를 손쉽게 제공합니다.

### 5) 보안/정보 노출 최소화
- 스택트레이스나 내부 에러 메시지 같은 민감 정보 노출을 차단합니다.
- 외부에는 안전한 사용자 메시지, 내부 로그에는 상세 메시지로 구분할 수 있습니다.

### 6) 유지보수·확장 용이
- 새 예외 타입 추가/변경 시 한 파일만 수정하면 전역 반영됩니다.
- 도메인별 오류 코드 규칙을 Enum으로 관리하기 쉽습니다.

---

## RestControllerAdvice가 없을 때의 불편함

**1. 응답 포맷 불일치**
- 컨트롤러/메서드마다 에러 JSON 구조가 달라져, 프런트/앱에서 분기 처리 코드가 많아진다.
- 팀원/버전별로 포맷이 달라지는 일관성 붕괴.

**2. 중복 try-catch 지옥**
- 모든 엔드포인트에 예외 처리 로직을 반복 작성 → 코드 부풀림 & 누락 위험.

**3. 로깅 품질 저하**
- 로그 포맷이 제각각이라 검색/집계가 어려움.
- 운영 중 장애 원인 파악 시간이 늘어납니다.

**4. 검증 오류 처리의 중복·불안정**
- `@Valid` 오류를 각 컨트롤러에서 다르게 처리 → 사용자 경험 불균형.

**5. 보안 취약**
- 실수로 스택 트레이스/SQL 메시지 등이 응답에 노출될 수 있음.

**6. 수정 난이도 상승**
- 예외 응답 정책을 바꾸려면 모든 컨트롤러를 돌아다니며 수정해야 함.